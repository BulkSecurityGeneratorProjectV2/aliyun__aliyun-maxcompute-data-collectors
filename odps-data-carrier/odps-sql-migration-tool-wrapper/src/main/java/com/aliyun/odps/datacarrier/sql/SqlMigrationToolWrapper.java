package com.aliyun.odps.datacarrier.sql;

import com.aliyun.odps.datacarrier.commons.GeneratedStatement;
import com.aliyun.odps.datacarrier.commons.MetaManager;
import com.aliyun.odps.datacarrier.commons.MetaManager.DatabaseMetaModel;
import com.aliyun.odps.datacarrier.commons.MetaManager.GlobalMetaModel;
import com.aliyun.odps.datacarrier.commons.MetaManager.TableMetaModel;
import com.aliyun.odps.datacarrier.metaprocessor.MetaProcessor;
import com.aliyun.odps.tool.migration.CompatibilityDescription;
import com.aliyun.odps.tool.migration.Issue;
import com.aliyun.odps.tool.migration.Meta;
import com.aliyun.odps.tool.migration.SqlCompatibilityChecker;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;

/**
 * @author wangzhong.zw
 */
public class SqlMigrationToolWrapper {
  private MetaManager metaManager;
  private MetaProcessor metaProcessor;

  /**
   * @param root path to the directory generated by meta-processor, which contains all the odps DDL
   */
  public SqlMigrationToolWrapper(String root) throws IOException {
    this.metaManager = new MetaManager(root);
    this.metaProcessor = new MetaProcessor();
  }

  private List<String> getOdpsDdlList() throws IOException {
    List<String> odpsDdlList = new ArrayList<>();

    GlobalMetaModel globalMeta = metaManager.getGlobalMeta();
    for (String databaseName : metaManager.listDatabases()) {
      DatabaseMetaModel databaseMeta = metaManager.getDatabaseMeta(databaseName);
      for (String tableName : metaManager.listTables(databaseName)) {
        TableMetaModel tableMeta = metaManager.getTableMeta(databaseName, tableName);
        GeneratedStatement statement =
            metaProcessor.getCreateTableStatement(globalMeta, databaseMeta, tableMeta);
        odpsDdlList.add(statement.getStatement());
      }
    }

    return odpsDdlList;
  }

  public CompatibilityDescription check(String defaultProject, String sql,
      Map<String, String> settings) throws IOException {
    List<String> odpsDdlList = getOdpsDdlList();
    String odpsDdl = String.join("\n", odpsDdlList);
    SqlCompatibilityChecker checker =
        SqlCompatibilityChecker.create(defaultProject, Meta.ddl(odpsDdl));
    return checker.check(sql, settings);
  }

  private String getformattedCompatibilityDescription(CompatibilityDescription description) {
    StringBuilder descriptionBuilder = new StringBuilder();
    descriptionBuilder
        .append("Compatibility: ")
        .append(description.getCompatibility())
        .append("\n");

    List<Issue> issues = description.getIssues();
    if (!issues.isEmpty()) {
      descriptionBuilder.append("Issues:").append("\n");
      for (int i = 0; i < issues.size(); i++) {
        Issue issue = issues.get(i);
        descriptionBuilder.append("  ").append(i).append(".\n");
        descriptionBuilder
            .append("  ")
            .append("Compatibility: ")
            .append(issue.getCompatibility())
            .append("\n");
        descriptionBuilder
            .append("  ")
            .append("Description: ")
            .append(issue.getDescription())
            .append("\n");
        descriptionBuilder
            .append("  ")
            .append("Suggestion: ")
            .append(issue.getSuggestion())
            .append("\n");
      }
    }

    return descriptionBuilder.toString();
  }

  public static void main(String[] args) throws ParseException, IOException {
    Option project = Option
        .builder("p")
        .longOpt("project")
        .argName("project")
        .hasArg()
        .desc("Default odps project")
        .build();
    Option inputDir = Option
        .builder("i")
        .longOpt("input-dir")
        .argName("input-dir")
        .hasArg()
        .desc("Directory generated by meta carrier, which contains all the metadata")
        .build();
    Option sql = Option
        .builder()
        .longOpt("sql")
        .argName("sql")
        .hasArg()
        .desc("Sql statements to check")
        .build();
    Option settings = Option
        .builder()
        .longOpt("settings")
        .hasArgs()
        .argName("settings")
        .desc("Odps settings")
        .build();
    Option help = Option
        .builder("h")
        .longOpt("help")
        .argName("help")
        .desc("Print help information")
        .build();

    Options options = new Options();
    options.addOption(project);
    options.addOption(inputDir);
    options.addOption(help);
    options.addOption(sql);
    options.addOption(settings);

    CommandLineParser parser = new DefaultParser();
    CommandLine cmd = parser.parse(options, args);

    if (validateCommandLine(cmd)) {
      Map<String, String> settingsValue = parseSettings(cmd);
      String projectValue = cmd.getOptionValue("project");
      String inputDirValue = cmd.getOptionValue("input-dir");
      String sqlValue = cmd.getOptionValue("sql");

      SqlMigrationToolWrapper checker = new SqlMigrationToolWrapper(inputDirValue);
      CompatibilityDescription description = checker.check(projectValue, sqlValue, settingsValue);
      String formattedDescription = checker.getformattedCompatibilityDescription(description);
      System.out.println(formattedDescription);
    } else {
      HelpFormatter formatter = new HelpFormatter();
      String cmdLineSyntax =
          "sql-checker -i <metadata dir> -p <default odps project> --sql <sql to check> "
              + "[--settings k=v k=v ...]";
      formatter.printHelp(cmdLineSyntax, options);
    }
  }

  private static boolean validateCommandLine(CommandLine cmd) {
    return cmd.hasOption("sql") && cmd.hasOption("input-dir")
        && cmd.hasOption("project") && !cmd.hasOption("help");
  }

  private static Map<String, String> parseSettings(CommandLine cmd) {
    Map<String, String> settings = new HashMap<>();
    if (cmd.hasOption("settings")) {
      String[] values = cmd.getOptionValues("settings");
      for (String value : values) {
        String[] kv = value.split("=");
        if (kv.length != 2) {
          throw new IllegalArgumentException("Invalid setting: " + value);
        }
        settings.put(kv[0], kv[1]);
      }
    }

    return settings;
  }
}
